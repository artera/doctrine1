<?php

namespace Doctrine1\Migration;

use Laminas\Code\Generator\ValueGenerator;

class Builder
{
    /**
     * The path to your migration classes directory
     */
    private string $migrationsPath = '';

    /**
     * File suffix to use when writing class definition
     */
    private string $suffix = '.php';

    /**
     * Instance of the migration class for the migration classes directory
     */
    private \Doctrine1\Migration $migration;

    /**
     * Class template used for writing classes
     */
    protected static string $tpl;

    /**
     * Instantiate new instance of the \Doctrine1\Migration\Builder class
     *
     * <code>
     * $builder = new \Doctrine1\Migration\Builder('/path/to/migrations');
     * </code>
     *
     * @param  \Doctrine1\Migration|string $migrationsPath
     * @return void
     */
    public function __construct($migrationsPath = null)
    {
        if ($migrationsPath instanceof \Doctrine1\Migration) {
            $this->setMigrationsPath($migrationsPath->getMigrationClassesDirectory());
            $this->migration = $migrationsPath;
        } elseif ($migrationsPath !== null && is_dir($migrationsPath)) {
            $this->setMigrationsPath($migrationsPath);
            $this->migration = new \Doctrine1\Migration($migrationsPath);
        }

        $this->loadTemplate();
    }

    /**
     * Set the path to write the generated migration classes
     *
     * @param  string $path the path where migration classes are stored and being generated
     * @return void
     */
    public function setMigrationsPath(string $path): void
    {
        \Doctrine1\Lib::makeDirectories($path);

        $this->migrationsPath = $path;
    }

    /**
     * Get the path where generated migration classes are written to
     *
     * @return string       the path where migration classes are stored and being generated
     */
    public function getMigrationsPath(): string
    {
        return $this->migrationsPath;
    }

    /**
     * Loads the class template used for generating classes
     */
    protected function loadTemplate(): void
    {
        if (isset(self::$tpl)) {
            return;
        }

        self::$tpl = <<<END
/**
 * This class has been auto-generated by the Doctrine ORM Framework
 */
class %s extends %s
{
    public function up()
    {
%s
    }

    public function down()
    {
%s
    }
}
END;
    }

    /**
     * Generate a set of migration classes from the existing databases
     *
     * @return bool
     */
    public function generateMigrationsFromDb()
    {
        $directory = sys_get_temp_dir() . DIRECTORY_SEPARATOR . 'tmp_doctrine_models';

        \Doctrine1\Core::generateModelsFromDb($directory);

        $result = $this->generateMigrationsFromModels($directory);

        \Doctrine1\Lib::removeDirectories($directory);

        return $result;
    }

    /**
     * Generate a set of migrations from a set of models
     *
     * @param  string|null $modelsPath   Path to models
     */
    public function generateMigrationsFromModels(?string $modelsPath = null): bool
    {
        if ($modelsPath !== null) {
            $models = \Doctrine1\Core::filterInvalidModels(\Doctrine1\Core::loadModels($modelsPath));
        } else {
            $models = \Doctrine1\Core::getLoadedModels();
        }

        $models = \Doctrine1\Core::initializeModels($models);

        $foreignKeys = [];

        foreach ($models as $model) {
            $table = \Doctrine1\Core::getTable($model);
            if ($table->getTableName() !== $this->migration->getTableName()) {
                $export = $table->getExportableFormat();

                $foreignKeys[$export['tableName']] = $export['options']['foreignKeys'];

                $up   = $this->buildCreateTable($export);
                $down = $this->buildDropTable($export);

                $className = 'Add' . \Doctrine1\Inflector::classify($export['tableName']);

                $this->generateMigrationClass($className, [], $up, $down);
            }
        }

        if (!empty($foreignKeys)) {
            $className = 'AddFks';

            $up   = [];
            $down = [];
            foreach ($foreignKeys as $tableName => $definitions) {
                $tableForeignKeyNames[$tableName] = [];

                foreach ($definitions as $definition) {
                    $up[]   = $this->buildCreateForeignKey($tableName, $definition);
                    $down[] = $this->buildDropForeignKey($tableName, $definition);
                }
            }

            $up   = implode("\n", $up);
            $down = implode("\n", $down);
            if ($up || $down) {
                $this->generateMigrationClass($className, [], $up, $down);
            }
        }

        return true;
    }

    /**
     * Build the code for creating foreign keys
     */
    public function buildCreateForeignKey(string $tableName, array $definition): string
    {
        return "        \$this->createForeignKey('" . $tableName . "', '" . $definition['name'] . "', " . $this->varExport($definition) . ');';
    }

    /**
     * Build the code for dropping foreign keys
     */
    public function buildDropForeignKey(string $tableName, array $definition): string
    {
        return "        \$this->dropForeignKey('" . $tableName . "', '" . $definition['name'] . "');";
    }

    /**
     * Build the code for creating tables
     */
    public function buildCreateTable(array $tableData): string
    {
        $code = "        \$this->createTable('" . $tableData['tableName'] . "', ";

        $code .= $this->varExport($tableData['columns']) . ', ';

        $optionsWeNeed = ['type', 'indexes', 'primary', 'collate', 'charset'];

        $options = [];
        foreach ($optionsWeNeed as $option) {
            if (isset($tableData['options'][$option])) {
                $options[$option] = $tableData['options'][$option];
            }
        }

        $code .= $this->varExport($options);

        $code .= ');';

        return $code;
    }

    /**
     * Build the code for dropping tables
     */
    public function buildDropTable(array $tableData): string
    {
        return "        \$this->dropTable('" . $tableData['tableName'] . "');";
    }

    /**
     * Build the code for adding columns
     */
    public function buildAddColumn(string $tableName, string $columnName, array $column): string
    {
        $length = $column['length'];
        $type   = $column['type'];
        unset($column['length'], $column['type']);
        return "        \$this->addColumn('" . $tableName . "', '" . $columnName . "', '" . $type . "', '" . $length . "', " . $this->varExport($column) . ');';
    }

    /**
     * Build the code for removing columns
     */
    public function buildRemoveColumn(string $tableName, string $columnName, array $column): string
    {
        return "        \$this->removeColumn('" . $tableName . "', '" . $columnName . "');";
    }

    /**
     * Build the code for changing columns
     */
    public function buildChangeColumn(string $tableName, string $columnName, array $column): string
    {
        $length = $column['length'];
        $type   = $column['type'];
        unset($column['length'], $column['type']);
        return "        \$this->changeColumn('" . $tableName . "', '" . $columnName . "', '" . $type . "', '" . $length . "', " . $this->varExport($column) . ');';
    }

    /**
     * Build the code for adding indexes
     */
    public function buildAddIndex(string $tableName, string $indexName, string $index): string
    {
        return "        \$this->addIndex('$tableName', '$indexName', " . $this->varExport($index) . ');';
    }

    /**
     * Build the code for removing indexes
     */
    public function buildRemoveIndex(string $tableName, string $indexName, string $index): string
    {
        return "        \$this->removeIndex('$tableName', '$indexName', " . $this->varExport($index) . ');';
    }

    /**
     * Generate a migration class
     *
     * @param  string  $className Class name to generate
     * @param  array   $options   Options for the migration class
     * @param  string  $up        The code for the up function
     * @param  string  $down      The code for the down function
     * @param  boolean $return    Whether or not to return the code.
     *                            If true return and false it writes
     *                            the class to disk.
     */
    public function generateMigrationClass(string $className, array $options = [], ?string $up = null, ?string $down = null, bool $return = false): string|bool
    {
        $migrationsPath = $this->getMigrationsPath();
        if ($return || !$migrationsPath) {
            return $this->buildMigrationClass($className, null, $options, $up, $down);
        } else {
            $next = time() + $this->migration->getNextMigrationClassVersion();
            $fileName = $next . '_' . \Doctrine1\Inflector::tableize($className) . $this->suffix;

            $class = $this->buildMigrationClass($className, $fileName, $options, $up, $down);

            if (is_subclass_of($className, Base::class)) {
                $this->migration->loadMigrationClass($className);
                return false;
            }

            $path = "$migrationsPath/$fileName";
            file_put_contents($path, $class);
            include_once $path;
            assert(is_subclass_of($className, Base::class));
            $this->migration->loadMigrationClass($className);

            return true;
        }
    }

    /**
     * Build the code for a migration class
     *
     * @param  string $className Class name to generate
     * @param  string $fileName  File name to write the class to
     * @param  array  $options   Options for the migration class
     * @param  string $up        The code for the up function
     * @param  string $down      The code for the down function
     * @return string $content     The code for the generated class
     */
    public function buildMigrationClass(string $className, ?string $fileName = null, array $options = [], string $up = null, string $down = null): string
    {
        return "<?php\n" . sprintf(
            self::$tpl,
            $className,
            $options['extends'] ?? ('\\' . Base::class),
            $up,
            $down
        );
    }

    private function varExport(mixed $var): string
    {
        return (string) (new ValueGenerator($var));
    }
}
